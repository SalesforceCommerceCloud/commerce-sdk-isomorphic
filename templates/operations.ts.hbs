{{#each encodes.endPoints}}
  {{#each operations}}

    /**
    * {{{formatForTsDoc description}}}
    *
    * If you would like to get a raw Response object use the other {{name}} function.
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    {{#each ../parameters }}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    {{#each request/queryParameters}}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    {{#if (isRequestWithPayload request)}}
    * @param body - The data to send as the request body.
    {{/if}}
    *
    * @returns A promise of type {{getReturnTypeFromOperation this}}.
    * {{#if (eq (lowercase @root.metadata.categories.[CC Version Status].[0]) "beta")}}
    * @beta
    * {{/if}}
    */
    {{name}}(
      options{{#or (is method "get") (is method "delete")}}?{{/or}}: RequireParametersUnlessAllAreOptional<{
        parameters?: CompositeParameters<{
          {{#each ../parameters}}
          {{{name}}}: {{{ getTypeFromParameter this}}}
          {{/each}}
          {{#each request.queryParameters}}
          {{{name}}}{{#if (not (is required "true"))}}?{{/if}}: {{{ getTypeFromParameter this}}}
          {{/each}}
        } & { [key in `c_${string}`]: any }, ConfigParameters>,
        headers?: { [key: string]: string },
        {{#if (isRequestWithPayload request)}}
        body: {{{getPayloadTypeFromRequest request}}}
        {{/if}}
      }>
    ): Promise<{{getReturnTypeFromOperation this}}>;

    /**
    * {{{formatForTsDoc description}}}
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    {{#each ../parameters }}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    {{#each request.queryParameters}}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    {{#if (isRequestWithPayload request)}}
    * @param body - The data to send as the request body.
    {{/if}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * @returns A promise of type Response if rawResponse is true, a promise of type {{getReturnTypeFromOperation this}} otherwise.
    * {{#if (eq (lowercase @root.metadata.categories.[CC Version Status].[0]) "beta")}}
    * @beta
    * {{/if}}
    */
    {{name}}<T extends boolean>(
      options{{#or (is method "get") (is method "delete")}}?{{/or}}: RequireParametersUnlessAllAreOptional<{
        parameters?: CompositeParameters<{
          {{#each ../parameters}}
          {{{name}}}: {{{ getTypeFromParameter this}}}
          {{/each}}
          {{#each request.queryParameters}}
          {{{name}}}{{#if (not (is required "true"))}}?{{/if}}: {{{ getTypeFromParameter this}}}
          {{/each}}
        } & { [key in `c_${string}`]: any }, ConfigParameters>,
        headers?: { [key: string]: string },
        {{#if (isRequestWithPayload request)}}
        body: {{{getPayloadTypeFromRequest request}}}
        {{/if}}
      }>,
      rawResponse?: T
    ): Promise<T extends true ? Response : {{getReturnTypeFromOperation this}}>;

    /**
    * {{{formatForTsDoc description}}}
    *
    * @param options - An object containing the options for this method.
    * @param parameters - An object containing the parameters for this method.
    {{#each ../parameters }}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    {{#each request.queryParameters}}
    * @param {{{name}}} - {{#if (getValue description)}}{{{getValue description}}}{{/if}}
    {{/each}}
    * @param headers - An object literal of key value pairs of the headers to be
    * sent with this request.
    {{#if (isRequestWithPayload request)}}
    * @param body - The data to send as the request body.
    {{/if}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    *
    * @returns A promise of type Response if rawResponse is true, a promise of type {{getReturnTypeFromOperation this}} otherwise.
    * {{#if (eq (lowercase @root.metadata.categories.[CC Version Status].[0]) "beta")}}
    * @beta
    * {{/if}}
    */
    async {{name}}(
      options{{#or (is method "get") (is method "delete")}}?{{/or}}: RequireParametersUnlessAllAreOptional<{
        parameters?: CompositeParameters<{
          {{#each ../parameters}}
          {{{name}}}: {{{ getTypeFromParameter this}}}
          {{/each}}
          {{#each request.queryParameters}}
          {{{name}}}{{#if (not (is required "true"))}}?{{/if}}: {{{ getTypeFromParameter this}}}
          {{/each}}
        } & { [key in `c_${string}`]: any }, ConfigParameters>,
        headers?: { [key: string]: string },
        {{#if (isRequestWithPayload request)}}
        body: {{{getPayloadTypeFromRequest request}}}
        {{/if}}
      }>,
      rawResponse?: boolean
    ): Promise<Response | {{getReturnTypeFromOperation this}}> {
      const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>["parameters"]>>);
      const configParams = this.clientConfig.parameters;

      const pathParams: {{{@root.name.upperCamelCase}}}PathParameters & Required<BaseUriParameters> = {
        {{!-- Base URI parameters are well known and unlikely to change, so they are hard-coded for simplicity  --}}
        shortCode: configParams.shortCode,
        version: configParams.version || "v1"
      };
      // TODO: try extracting this
      {{{name}}}PathParamKeys.forEach((paramKey) => {
        const value = optionParams[paramKey] ?? configParams[paramKey];

        if (value !== undefined) {
          pathParams[paramKey] = value;
        } else {
          const isRequired = {{{name}}}ParamKeysRequired.includes(paramKey);
          if (isRequired) {
            throwMissingRequiredParamError({name: paramKey, paramType: 'path'})
          }
        }
      });

      const queryParams: {{{@root.name.upperCamelCase}}}QueryParameters & { [key in `c_${string}`]: any } = {};
      // TODO: try extracting this
      {{{name}}}QueryParamKeys.forEach((paramKey) => {
        const value = optionParams[paramKey] ?? configParams[paramKey];

        if (value !== undefined) {
          // @ts-ignore
          queryParams[paramKey] = value;
        } else {
          // @ts-ignore
          const isRequired = {{{name}}}ParamKeysRequired.includes(paramKey);
          if (isRequired) {
            throwMissingRequiredParamError({name: paramKey, paramType: 'query'})
          }
        }
      });

      // TODO: try extracting this
      Object.keys(optionParams).forEach((key) => {
        if(key.startsWith('c_') && optionParams[key as keyof typeof optionParams] !== undefined) {
          queryParams[key as keyof typeof queryParams] = optionParams[key as keyof typeof optionParams]
        } else if(!queryParams.hasOwnProperty(key) && !pathParams.hasOwnProperty(key)) {
          warnInvalidParam({ paramName: key, methodName: '{{{name}}}' })
        }
      })

      const url = new TemplateURL(
        "{{{../path}}}",
        this.clientConfig.baseUri,
        {
          pathParams,
          queryParams,
          origin: this.clientConfig.proxy
        }
      );

      const headers: Record<string, string> = {
        {{#if (isRequestWithPayload request)}}
        "Content-Type": "{{{getMediaTypeFromRequest request}}}",
        {{/if}}
        ...this.clientConfig.headers,
        ...options?.headers
      };

      if (!isBrowser) {
        // Browsers forbid setting a custom user-agent header
        headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(" ");
      }

      const response = await doFetch(
        url.toString(),
        {
          method: "{{loud method}}",
          headers,
          {{#if (isRequestWithPayload request)}}body: this.clientConfig.transformRequest(options.body, headers){{/if}}
        },
        this.clientConfig,
        rawResponse
      )

      {{#if (eq (getReturnTypeFromOperation this) "void") }}
      if (rawResponse) {
        return response as Response;
      }
      {{else}}
      return response as Response | {{getReturnTypeFromOperation this}};
      {{/if}}
    }
  {{/each}}
{{/each}}
