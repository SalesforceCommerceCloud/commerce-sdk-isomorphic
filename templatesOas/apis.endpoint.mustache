
{{! This partial expects to be wrapped in operations/operation }}
{{! and renders the endpoint function for each operation, making the API fetch call }}
    /**
    * {{{unescapedNotes}}}
    *
    * If you would like to get a raw Response object use the other {{nickname}} function.
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    *
    * @returns A promise of type {{{returnType}}}{{^returnType}}void{{/returnType}}.
    */
    {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
            {{^isBodyParam}}
            {{^isHeaderParam}}
            {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/isHeaderParam}}
            {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>
    ): Promise<{{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    {{nickname}}<T extends boolean>(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: T
    ): Promise<T extends true ? Response : {{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}    
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    async {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>,
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: boolean
    ): Promise<Response | {{{returnType}}}{{^returnType}}void{{/returnType}}> {
        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>["parameters"]>>);
        const configParams = this.clientConfig.parameters;
        
        const pathParams: {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}PathParameters & Required<BaseUriParameters> = {
          shortCode: configParams.shortCode,
          version: "v1"
        };

        {{#pathParams}}
        if (optionParams["{{paramName}}"] !== undefined) {
            pathParams["{{paramName}}"] = optionParams["{{paramName}}"];
        } else if (configParams["{{paramName}}"] !== undefined) {
            pathParams["{{paramName}}"] = configParams["{{paramName}}"];
        }
        {{#required}}
        else {
            throw new Error('Missing required path parameter: {{paramName}}');
        }
        {{/required}}
        {{/pathParams}}

        const queryParams: Partial<{{nickname}}QueryParameters> & QueryParameters = {};

        {{#queryParams}}
        if (optionParams["{{paramName}}"] !== undefined) {
            queryParams["{{paramName}}"] = optionParams["{{paramName}}"];
        } else if (configParams["{{paramName}}"] !== undefined) {
            queryParams["{{paramName}}"] = configParams["{{paramName}}"];
        }
        {{#required}}
        else {
            throw new Error('Missing required query parameter: {{paramName}}');
        }
        {{/required}}
        {{/queryParams}}

        Object.keys(optionParams).forEach((key) => {
            const paramValue = optionParams[key as keyof typeof optionParams];
            if(paramValue !== undefined && (key.startsWith('c_') || !((key in queryParams) || (key in pathParams)))) {
                if(!key.startsWith('c_')) {
                    console.warn(`Found unknown parameter for {{{nickname}}}: ${key}, adding as query parameter anyway`);
                }
                queryParams[key as keyof typeof queryParams] = paramValue;
            }
        })

        const url = new TemplateURL(
            "{{{path}}}",
            this.clientConfig.baseUri,
            {
                pathParams,
                queryParams,
                origin: this.clientConfig.proxy
            }
        );

        const headers: Record<string, string> = {
            {{#hasConsumes}}
            {{#consumes}}
            "Content-Type": "{{mediaType}}",
            {{/consumes}}
            {{/hasConsumes}}
            ...this.clientConfig.headers,
            ...options?.headers
        };

        if (!isBrowser) {
            // Browsers forbid setting a custom user-agent header
            headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(" ");
        }

        const response = await doFetch(
            url.toString(),
            {
                method: '{{httpMethod}}',
                headers,
                {{#hasBodyParam}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasBodyParam}}
                {{^hasBodyParam}}
                {{#hasFormParams}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasFormParams}}
                {{/hasBodyParam}}
            },
            this.clientConfig,
            rawResponse
        )

        {{^returnType}}
        if (rawResponse) {
            return response as Response;
        }
        {{/returnType}}
        {{#returnType}}
        return response as Response | {{{returnType}}};
        {{/returnType}}
    }