
{{! This partial expects to be wrapped in operations/operation }}
{{! and renders the endpoint function for each operation, making the API fetch call }}
    /**
    * {{{unescapedNotes}}}
    *
    * If you would like to get a raw Response object use the other {{nickname}} function.
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    *
    * @returns A promise of type {{{returnType}}}{{^returnType}}void{{/returnType}}.
    */
    {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
            {{^isBodyParam}}
            {{^isHeaderParam}}
            {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/isHeaderParam}}
            {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>
    ): Promise<{{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    {{nickname}}<T extends boolean>(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: T
    ): Promise<T extends true ? Response : {{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}    
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    async {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>,
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}} & CustomRequestBody
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {{nickname}}BodyType & CustomRequestBody
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: boolean
    ): Promise<Response | {{{returnType}}}{{^returnType}}void{{/returnType}}> {
        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>["parameters"]>>);
        const configParams = this.clientConfig.parameters;
        
        const pathParams: {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}PathParameters & Required<BaseUriParameters> = {
          shortCode: configParams.shortCode,
          ...optionParams
        };

        const queryParams: Partial<{{nickname}}QueryParameters> & QueryParameters = {
          ...optionParams
        };

        const url = new TemplateURL(
            "{{{path}}}",
            this.clientConfig.baseUri,
            {
                pathParams,
                queryParams,
                origin: this.clientConfig.proxy
            }
        );

        const headers: Record<string, string> = {
            {{#hasConsumes}}
            {{#consumes}}
            "Content-Type": "{{mediaType}}",
            {{/consumes}}
            {{/hasConsumes}}
            ...this.clientConfig.headers,
            ...options?.headers
        };

        if (!isBrowser) {
            // Browsers forbid setting a custom user-agent header
            headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(" ");
        }

        const response = await doFetch(
            url.toString(),
            {
                method: '{{httpMethod}}',
                headers,
                {{#hasBodyParam}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasBodyParam}}
                {{^hasBodyParam}}
                {{#hasFormParams}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasFormParams}}
                {{/hasBodyParam}}
            },
            this.clientConfig,
            rawResponse
        )

        {{^returnType}}
        if (rawResponse) {
            return response as Response;
        }
        {{/returnType}}
        {{#returnType}}
        return response as Response | {{{returnType}}};
        {{/returnType}}
    }