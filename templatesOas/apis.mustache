import ClientConfig, { ClientConfigInit } from "../../../static/clientConfig";
// Must not import from ./helpers/index to avoid circular dependency via ShopperLogin
import { isBrowser } from "../../../static/helpers/environment";
import { defaultBaseUri as currentBaseUri } from "../runtime";
import { doFetch } from "../../../static/helpers/fetchHelper";
import type {
    BaseUriParameters,
    CompositeParameters,
    RequireParametersUnlessAllAreOptional
} from "../../../static/helpers/types";
import TemplateURL from "../../../static/templateUrl";
import { USER_AGENT_HEADER, USER_AGENT_VALUE } from "../../../static/version";
import { QueryParameters } from "../../helpers/types";

import type {
    {{#imports}}
    {{className}},
    {{/imports}}
} from '../models/index{{importFileExtension}}';

{{#hasEnums}}
{{#operations}}
{{#operation}}
{{#allParams}}
{{#isEnum}}
{{#stringEnums}}
export enum {{operationIdCamelCase}}{{enumName}} {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}} = {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
}
{{/stringEnums}}
{{^stringEnums}}

export const {{operationIdCamelCase}}{{enumName}} = {
{{#allowableValues}}
    {{#enumVars}}
    {{{name}}}: {{{value}}}{{^-last}},{{/-last}}
    {{/enumVars}}
{{/allowableValues}}
} as const;
export type {{operationIdCamelCase}}{{enumName}} = typeof {{operationIdCamelCase}}{{enumName}}[keyof typeof {{operationIdCamelCase}}{{enumName}}];
{{/stringEnums}}
{{/isEnum}}
{{/allParams}}
{{/operation}}
{{/operations}}
{{/hasEnums}}

{{#operations}}
{{#operation}}
export type {{nickname}}QueryParameters = {
    {{#queryParams}}
    {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{dataType}}}{{/isEnum}}{{^isEnum}}{{#hasReadOnly}}Omit<{{{dataType}}}, {{#readOnlyVars}}'{{baseName}}'{{^-last}}|{{/-last}}{{/readOnlyVars}}>{{/hasReadOnly}}{{^hasReadOnly}}{{{dataType}}}{{/hasReadOnly}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
    {{/queryParams}}
}

export type {{nickname}}PathParameters = {
    {{#pathParams}}
    {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{#hasReadOnly}}Omit<{{{dataType}}}, {{#readOnlyVars}}'{{baseName}}'{{^-last}}|{{/-last}}{{/readOnlyVars}}>{{/hasReadOnly}}{{^hasReadOnly}}{{{dataType}}}{{/hasReadOnly}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
    {{/pathParams}}
}

{{/operation}}
{{/operations}}

/**
 * All path parameters that are used by at least one {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}} method.
 */
export type {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}PathParameters = Partial<
    {{#operations}}
    {{#operation}}
    {{nickname}}PathParameters{{^-last}} &{{/-last}}
    {{/operation}}
    {{/operations}}
>;

/**
 * All query parameters that are used by at least one {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}} method.
 */
export type {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}QueryParameters = Partial<
    {{#operations}}
    {{#operation}}
    {{nickname}}QueryParameters{{^-last}} &{{/-last}}
    {{/operation}}
    {{/operations}}
>;

/**
 * All parameters that are used by {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}.
 */
export type {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}Parameters = {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}PathParameters & BaseUriParameters & {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}QueryParameters;

/**
* [{{appName}}](https://developer.salesforce.com/docs/commerce/commerce-api/references?meta={{#lambda.kebabcase}}{{appName}}{{/lambda.kebabcase}}:Summary)
* ==================================
*
* *{{{unescapedAppDescription}}}*<br />
*
* Simple example:
*
* ```typescript
*   import { {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}} } from "commerce-sdk-isomorphic";
*
*   const clientConfig = {
*     parameters: {
*       clientId: "XXXXXX",
*       organizationId: "XXXX",
*       shortCode: "XXX",
*       siteId: "XX"
*     }
*   };
*   const {{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}Client = new {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}(clientConfig);
* ```
*
* <span style="font-size:.7em; display:block; text-align: right">
* API Version: 0.0.33<br />
* Last Updated: <br />
* </span>
* 
*
*/
export class {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}<ConfigParameters extends {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}Parameters & Record<string, unknown>> {
    // baseUri is not required on ClientConfig, but we know that we provide one in the class constructor
    public clientConfig: ClientConfig<ConfigParameters> & { baseUri: string };

    static readonly defaultBaseUri = currentBaseUri;

    static readonly apiPaths = {
        {{#operations}}
        {{#operation}}
        {{nickname}}: "{{path}}",
        {{/operation}}
        {{/operations}}
    }

    constructor(config: ClientConfigInit<ConfigParameters>) {
        const cfg = {...config}
        if (!cfg.baseUri) cfg.baseUri = new.target.defaultBaseUri;
        // Type assertion is safe because ^^^
        this.clientConfig = new ClientConfig(cfg) as ClientConfig<ConfigParameters> & { baseUri: string };
    }

    static readonly paramKeys = {
    {{#operations}}
    {{#operation}}
        {{nickname}}: [
            {{#allParams}}
            {{^isBodyParam}}
            {{^isHeaderParam}}
            '{{paramName}}',
            {{/isHeaderParam}}
            {{/isBodyParam}}
            {{/allParams}}
        ],
        {{nickname}}Required: [
            {{#allParams}}
            {{^isBodyParam}}
            {{^isHeaderParam}}
            {{#required}}
            '{{paramName}}',
            {{/required}}
            {{/isHeaderParam}}
            {{/isBodyParam}}
            {{/allParams}}
        ],
    {{/operation}}
    {{/operations}}
    } as const;

{{#operations}}
{{#operation}}

    /**
    * {{{unescapedNotes}}}
    *
    * If you would like to get a raw Response object use the other {{nickname}} function.
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    *
    * @returns A promise of type {{{returnType}}}{{^returnType}}void{{/returnType}}.
    */
    {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
            {{^isBodyParam}}
            {{^isHeaderParam}}
            {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/isHeaderParam}}
            {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}}
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {
            {{#formParams}}
            {{#isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{dataType}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/formParams}}
            }
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>
    ): Promise<{{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    {{nickname}}<T extends boolean>(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}}
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {
            {{#formParams}}
            {{#isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{dataType}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/formParams}}
            }
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: T
    ): Promise<T extends true ? Response : {{{returnType}}}{{^returnType}}void{{/returnType}}>;

    /**
    * {{{unescapedNotes}}}
    *
    * @param options - An object containing the options for this method.
    * @param options.parameters - An object containing the parameters for this method.
    {{#allParams}}
    {{^isBodyParam}}
    {{^isHeaderParam}}
    {{^isFormParam}}
    * @param options.parameters.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/isHeaderParam}}    
    {{/isBodyParam}}
    {{/allParams}}
    * @param options.headers - An object literal of key value pairs of the headers to be sent with this request.
    {{#hasBodyParam}}
    * @param options.body - The data to send as the request body.
    {{/hasBodyParam}}
    {{^hasBodyParam}}
    {{#hasFormParams}}
    * @param options.body - The data to send as the request body.
    {{#formParams}}
    {{#isFormParam}}
    * @param options.body.{{{paramName}}} - {{{unescapedDescription}}}
    {{/isFormParam}}
    {{/formParams}}
    {{/hasFormParams}}
    {{/hasBodyParam}}
    * @param rawResponse - Set to true to return entire Response object instead of DTO.
    * 
    * @returns A promise of type Response if rawResponse is true, a promise of type {{{returnType}}}{{^returnType}}void{{/returnType}} otherwise.
    */
    async {{nickname}}(
        options{{^hasBodyParam}}?{{/hasBodyParam}}: RequireParametersUnlessAllAreOptional<{
            parameters?: CompositeParameters<{
            {{#allParams}}
                {{^isBodyParam}}
                {{^isHeaderParam}}
                {{^isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{datatypeWithEnum}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
                {{/isFormParam}}
                {{/isHeaderParam}}
                {{/isBodyParam}}
            {{/allParams}}
            } & QueryParameters, ConfigParameters>,
            headers?: { [key: string]: string },
            {{#hasBodyParam}}
            {{#bodyParam}}
            body: {{{dataType}}}
            {{/bodyParam}}
            {{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            body: {
            {{#formParams}}
            {{#isFormParam}}
                {{paramName}}{{^required}}?{{/required}}: {{#isEnum}}{{{dataType}}}{{/isEnum}}{{^isEnum}}{{^isDateTime}}{{^isDate}}{{{dataType}}}{{/isDate}}{{/isDateTime}}{{#isDateTime}}string{{/isDateTime}}{{#isDate}}string{{/isDate}}{{#isNullable}} | null{{/isNullable}}{{/isEnum}};
            {{/isFormParam}}
            {{/formParams}}
            }
            {{/hasFormParams}}
            {{/hasBodyParam}}
        }>,
        rawResponse?: boolean
    ): Promise<Response | {{{returnType}}}{{^returnType}}void{{/returnType}}> {
        const optionParams = options?.parameters || ({} as Partial<NonNullable<NonNullable<typeof options>["parameters"]>>);
        const configParams = this.clientConfig.parameters;
        
        const pathParams: {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}PathParameters & Required<BaseUriParameters> = {
          shortCode: configParams.shortCode,
          version: configParams.version || "v1"
        };

        {{#pathParams}}
        if (optionParams["{{paramName}}"] !== undefined) {
            pathParams["{{paramName}}"] = optionParams["{{paramName}}"];
        } else if (configParams["{{paramName}}"] !== undefined) {
            pathParams["{{paramName}}"] = configParams["{{paramName}}"];
        }
        {{#required}}
        else {
            throw new Error('Missing required path parameter: {{paramName}}');
        }
        {{/required}}
        {{/pathParams}}

        const queryParams: {{#lambda.titlecase}}{{#lambda.camelcase}}{{appName}}{{/lambda.camelcase}}{{/lambda.titlecase}}QueryParameters & QueryParameters = {};

        {{#queryParams}}
        if (optionParams["{{paramName}}"] !== undefined) {
            queryParams["{{paramName}}"] = optionParams["{{paramName}}"];
        } else if (configParams["{{paramName}}"] !== undefined) {
            queryParams["{{paramName}}"] = configParams["{{paramName}}"];
        }
        {{#required}}
        else {
            throw new Error('Missing required query parameter: {{paramName}}');
        }
        {{/required}}
        {{/queryParams}}

        Object.keys(optionParams).forEach((key) => {
            const paramValue = optionParams[key as keyof typeof optionParams];
            if(paramValue !== undefined && (key.startsWith('c_') || !((key in queryParams) || (key in pathParams)))) {
                if(!key.startsWith('c_')) {
                    console.warn(`Found unknown parameter for {{{nickname}}}: ${key}, adding as query parameter anyway`);
                }
                queryParams[key as keyof typeof queryParams] = paramValue;
            }
        })

        const url = new TemplateURL(
            "{{{path}}}",
            this.clientConfig.baseUri,
            {
                pathParams,
                queryParams,
                origin: this.clientConfig.proxy
            }
        );

        const headers: Record<string, string> = {
            {{#hasConsumes}}
            {{#consumes}}
            "Content-Type": "{{mediaType}}",
            {{/consumes}}
            {{/hasConsumes}}
            ...this.clientConfig.headers,
            ...options?.headers
        };

        if (!isBrowser) {
            // Browsers forbid setting a custom user-agent header
            headers[USER_AGENT_HEADER] = [headers[USER_AGENT_HEADER], USER_AGENT_VALUE].join(" ");
        }

        const response = await doFetch(
            url.toString(),
            {
                method: '{{httpMethod}}',
                headers,
                {{#hasBodyParam}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasBodyParam}}
                {{^hasBodyParam}}
                {{#hasFormParams}}
                body: this.clientConfig.transformRequest(options{{^hasBodyParam}}?{{/hasBodyParam}}.body, headers)
                {{/hasFormParams}}
                {{/hasBodyParam}}
            },
            this.clientConfig,
            rawResponse
        )

        {{^returnType}}
        if (rawResponse) {
            return response as Response;
        }
        {{/returnType}}
        {{#returnType}}
        return response as Response | {{{returnType}}};
        {{/returnType}}
    }
{{/operation}}
{{/operations}}
}
